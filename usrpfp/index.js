(function(exports,_vendetta,plugin,plugins,assets,toasts,metro,common,patcher$1,utils){"use strict";var _findByProps,_findByProps1,_findByProps2;metro.findByStoreName("ThemeStore"),metro.findByProps("triggerHaptic");const colorModule=metro.findByProps("colors","unsafe_rawColors");colorModule?.internal??colorModule?.meta,metro.findByProps("TextStyleSheet").TextStyleSheet,metro.findByName("Navigator")??((_findByProps=metro.findByProps("Navigator"))===null||_findByProps===void 0||_findByProps.Navigator),((_findByProps1=metro.findByProps("getRenderCloseButton"))===null||_findByProps1===void 0?void 0:_findByProps1.getRenderCloseButton)??((_findByProps2=metro.findByProps("getHeaderCloseButton"))===null||_findByProps2===void 0||_findByProps2.getHeaderCloseButton),metro.findByProps("popModal","pushModal");function fluxSubscribe(topic,callback){return common.FluxDispatcher.subscribe(topic,callback),function(){return common.FluxDispatcher.unsubscribe(topic,callback)}}metro.find(function(x){return x?.WebView&&!x.default}).WebView,metro.findByProps("SvgXml"),metro.findByProps("isJoi"),metro.findByProps("useSharedValue"),metro.findByProps("FlashList").FlashList;const zustand={create:metro.findByName("create")};metro.findByProps("pickSingle","isCancel");const RNMMKVManager=common.ReactNative.NativeModules.MMKVManager,RNFileManager=common.ReactNative.NativeModules.DCDFileManager??common.ReactNative.NativeModules.RTNFileManager;common.ReactNative.NativeModules.BundleUpdaterManager,common.ReactNative.NativeModules.DCDSoundManager;const RNFSManager=common.ReactNative.NativeModules.RNFSManager,normalizeFilePath=function(path){return path.startsWith("file://")?path.slice(7):path},getOptions=function(encoding){if(typeof encoding=="string"){if(["utf8","ascii","base64"].includes(encoding))return{encoding};throw new Error(`Invalid encoding type "${String(encoding)}"`)}else return encoding||{encoding:"utf8"}},readFileGeneric=function(filepath,encoding,command){const options=getOptions(encoding);return command(normalizeFilePath(filepath)).then(function(b64){let contents;return options.encoding==="utf8"?contents=Buffer.from(b64,"base64").toString("utf8"):options.encoding==="ascii"?contents=Buffer.from(b64,"base64").toString("ascii"):options.encoding==="base64"&&(contents=b64),contents})},resolveWrite=function(filepath){let write={style:null,path:null};const constants2=RNFileManager.getConstants();if(filepath.startsWith(constants2.DocumentsDirPath))write={style:"documents",path:filepath.slice(constants2.DocumentsDirPath.length+1)};else if(filepath.startsWith(constants2.CacheDirPath))write={style:"cache",path:filepath.slice(constants2.CacheDirPath.length+1)};else throw new Error(`File path "${String(filepath)}" is unsupported on versions <211.6 (not a caches/documents path, missing RNFS)`);return write},RNFS={unlink(filepath){if(RNFSManager)return RNFSManager.unlink(normalizeFilePath(filepath)).then(function(){});const write=resolveWrite(filepath);return RNFileManager.removeFile(write.style,write.path).then(function(){})},exists(filepath){return RNFSManager?RNFSManager.exists(normalizeFilePath(filepath)):RNFileManager.fileExists(normalizeFilePath(filepath))},readFile(filepath,encoding){if(RNFSManager)return readFileGeneric(filepath,encoding,RNFSManager.readFile);{const options=getOptions(encoding);if(options.encoding==="ascii")throw new Error('Encoding type "ascii" is unsupported on versions <211.6 (missing RNFS)');return RNFileManager.readFile(filepath,options.encoding)}},writeFile(filepath,contents,encoding){const options=getOptions(encoding);if(!RNFSManager){if(options.encoding==="ascii")throw new Error('Encoding type "ascii" is unsupported on versions <211.6 (missing RNFS)');const write=resolveWrite(filepath);return RNFileManager.writeFile(write.style,write.path,contents,options.encoding).then(function(){})}let b64;return options.encoding==="utf8"?b64=Buffer.from(contents,"utf8").toString("base64"):options.encoding==="ascii"?b64=Buffer.from(contents,"ascii").toString("base64"):options.encoding==="base64"&&(b64=contents),RNFSManager.writeFile(normalizeFilePath(filepath),b64,options)},mkdir(filepath){if(!RNFSManager)throw new Error("Function 'mkdir' is unsupported on versions <211.6 (missing RNFS)");return RNFSManager.mkdir(normalizeFilePath(filepath),{}).then(function(){})},MainBundlePath:RNFSManager?.RNFSMainBundlePath,get CachesDirectoryPath(){return RNFSManager?.RNFSCachesDirectoryPath??RNFileManager.getConstants().CacheDirPath},ExternalCachesDirectoryPath:RNFSManager?.RNFSExternalCachesDirectoryPath,get DocumentDirectoryPath(){return RNFSManager?.RNFSDocumentDirectoryPath??RNFileManager.getConstants().DocumentsDirPath},DownloadDirectoryPath:RNFSManager?.RNFSDownloadDirectoryPath,ExternalDirectoryPath:RNFSManager?.RNFSExternalDirectoryPath,ExternalStorageDirectoryPath:RNFSManager?.RNFSExternalStorageDirectoryPath,TemporaryDirectoryPath:RNFSManager?.RNFSTemporaryDirectoryPath,LibraryDirectoryPath:RNFSManager?.RNFSLibraryDirectoryPath,PicturesDirectoryPath:RNFSManager?.RNFSPicturesDirectoryPath,FileProtectionKeys:RNFSManager?.RNFSFileProtectionKeys,RoamingDirectoryPath:RNFSManager?.RNFSRoamingDirectoryPath,hasRNFS:!!RNFSManager};function createJSONStorage(getStorage,options){let storage;try{storage=getStorage()}catch{return}return{getItem:function(name){var _a;const parse=function(str2){return str2===null?null:JSON.parse(str2,void 0)},str=(_a=storage.getItem(name))!=null?_a:null;return str instanceof Promise?str.then(parse):parse(str)},setItem:function(name,newValue){return storage.setItem(name,JSON.stringify(newValue,void 0))},removeItem:function(name){return storage.removeItem(name)}}}const toThenable=function(fn){return function(input){try{const result=fn(input);return result instanceof Promise?result:{then(onFulfilled){return toThenable(onFulfilled)(result)},catch(_onRejected){return this}}}catch(e){return{then(_onFulfilled){return this},catch(onRejected){return toThenable(onRejected)(e)}}}}},oldImpl=function(config,baseOptions){return function(set,get,api){let options={getStorage:function(){return localStorage},serialize:JSON.stringify,deserialize:JSON.parse,partialize:function(state){return state},version:0,merge:function(persistedState,currentState){return{...currentState,...persistedState}},...baseOptions},hasHydrated=!1;const hydrationListeners=new Set,finishHydrationListeners=new Set;let storage;try{storage=options.getStorage()}catch{}if(!storage)return config(function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`),set(...args)},get,api);const thenableSerialize=toThenable(options.serialize),setItem=function(){const state=options.partialize({...get()});let errorInSync;const thenable=thenableSerialize({state,version:options.version}).then(function(serializedValue){return storage.setItem(options.name,serializedValue)}).catch(function(e){errorInSync=e});if(errorInSync)throw errorInSync;return thenable},savedSetState=api.setState;api.setState=function(state,replace){savedSetState(state,replace),setItem()};const configResult=config(function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];set(...args),setItem()},get,api);let stateFromStorage;const hydrate=function(){var _a;if(!storage)return;hasHydrated=!1,hydrationListeners.forEach(function(cb){return cb(get())});const postRehydrationCallback=((_a=options.onRehydrateStorage)==null?void 0:_a.call(options,get()))||void 0;return toThenable(storage.getItem.bind(storage))(options.name).then(function(storageValue){if(storageValue)return options.deserialize(storageValue)}).then(function(deserializedStorageValue){if(deserializedStorageValue)if(typeof deserializedStorageValue.version=="number"&&deserializedStorageValue.version!==options.version){if(options.migrate)return options.migrate(deserializedStorageValue.state,deserializedStorageValue.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return deserializedStorageValue.state}).then(function(migratedState){var _a2;return stateFromStorage=options.merge(migratedState,(_a2=get())!=null?_a2:configResult),set(stateFromStorage,!0),setItem()}).then(function(){postRehydrationCallback?.(stateFromStorage,void 0),hasHydrated=!0,finishHydrationListeners.forEach(function(cb){return cb(stateFromStorage)})}).catch(function(e){postRehydrationCallback?.(void 0,e)})};return api.persist={setOptions:function(newOptions){options={...options,...newOptions},newOptions.getStorage&&(storage=newOptions.getStorage())},clearStorage:function(){storage?.removeItem(options.name)},getOptions:function(){return options},rehydrate:function(){return hydrate()},hasHydrated:function(){return hasHydrated},onHydrate:function(cb){return hydrationListeners.add(cb),function(){hydrationListeners.delete(cb)}},onFinishHydration:function(cb){return finishHydrationListeners.add(cb),function(){finishHydrationListeners.delete(cb)}}},hydrate(),stateFromStorage||configResult}},newImpl=function(config,baseOptions){return function(set,get,api){let options={storage:createJSONStorage(function(){return localStorage}),partialize:function(state){return state},version:0,merge:function(persistedState,currentState){return{...currentState,...persistedState}},...baseOptions},hasHydrated=!1;const hydrationListeners=new Set,finishHydrationListeners=new Set;let storage=options.storage;if(!storage)return config(function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`),set(...args)},get,api);const setItem=function(){const state=options.partialize({...get()});return storage.setItem(options.name,{state,version:options.version})},savedSetState=api.setState;api.setState=function(state,replace){savedSetState(state,replace),setItem()};const configResult=config(function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];set(...args),setItem()},get,api);api.getInitialState=function(){return configResult};let stateFromStorage;const hydrate=function(){var _a,_b;if(!storage)return;hasHydrated=!1,hydrationListeners.forEach(function(cb){var _a2;return cb((_a2=get())!=null?_a2:configResult)});const postRehydrationCallback=((_b=options.onRehydrateStorage)==null?void 0:_b.call(options,(_a=get())!=null?_a:configResult))||void 0;return toThenable(storage.getItem.bind(storage))(options.name).then(function(deserializedStorageValue){if(deserializedStorageValue)if(typeof deserializedStorageValue.version=="number"&&deserializedStorageValue.version!==options.version){if(options.migrate)return options.migrate(deserializedStorageValue.state,deserializedStorageValue.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return deserializedStorageValue.state}).then(function(migratedState){var _a2;return stateFromStorage=options.merge(migratedState,(_a2=get())!=null?_a2:configResult),set(stateFromStorage,!0),setItem()}).then(function(){postRehydrationCallback?.(stateFromStorage,void 0),stateFromStorage=get(),hasHydrated=!0,finishHydrationListeners.forEach(function(cb){return cb(stateFromStorage)})}).catch(function(e){postRehydrationCallback?.(void 0,e)})};return api.persist={setOptions:function(newOptions){options={...options,...newOptions},newOptions.storage&&(storage=newOptions.storage)},clearStorage:function(){storage?.removeItem(options.name)},getOptions:function(){return options},rehydrate:function(){return hydrate()},hasHydrated:function(){return hasHydrated},onHydrate:function(cb){return hydrationListeners.add(cb),function(){hydrationListeners.delete(cb)}},onFinishHydration:function(cb){return finishHydrationListeners.add(cb),function(){finishHydrationListeners.delete(cb)}}},options.skipHydration||hydrate(),stateFromStorage||configResult}},persist=function(config,baseOptions){return"getStorage"in baseOptions||"serialize"in baseOptions||"deserialize"in baseOptions?(console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),oldImpl(config,baseOptions)):newImpl(config,baseOptions)};var constants={github:{url:"https://github.com/nexpid/BunnyPlugins/",raw:"https://raw.githubusercontent.com/nexpid/BunnyPlugins/main/"}};const useLangStore=zustand.create(persist(function(set,get){return{values:{},lastModified:null,update:async function(plugin2){const res=await fetch(`${constants.github.raw}lang/values/${plugin2}.json`,{headers:{"if-modified-since":get().lastModified}});if(!res.ok)return;const values=await res.json();set({lastModified:res.headers.get("last-modified"),values})}}},{name:"nexpid-lang",storage:createJSONStorage(function(){return RNMMKVManager}),partialize:function(state){return{values:state.values,lastModified:state.lastModified}},onRehydrateStorage:function(){return function(){return RNMMKVManager.removeItem("nexpid-lang")}}}));var define_DEFAULT_LANG_default2={"log.patch_error":"Encountered an error while loading!","log.fetch_error":"Failed to fetch avatars!","toast.patch_error":"UsrPFP encountered an error while loading!","toast.fetch_error":"UsrPFP failed to fetch avatars!"};function _class_call_check(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError("Cannot call a class as a function")}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,"value"in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}}function _create_class(Constructor,protoProps,staticProps){return protoProps&&_defineProperties(Constructor.prototype,protoProps),staticProps&&_defineProperties(Constructor,staticProps),Constructor}function _define_property(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}const IntlMessageFormat=metro.findByName("MessageFormat");RNFS.exists(`${RNFS.DocumentDirectoryPath}/vendetta/NexpidLang`).then(function(yes){return yes&&RNFS.unlink(`${RNFS.DocumentDirectoryPath}/vendetta/NexpidLang`)});let Lang=function(){function Lang2(plugin2){var _this=this;_class_call_check(this,Lang2),_define_property(this,"plugin",void 0),_define_property(this,"_unload",void 0),_define_property(this,"Values",void 0),this.plugin=plugin2,useLangStore.persist.setOptions({name:`nexpid-lang-${plugin2}`,onRehydrateStorage:function(){return function(state){return state.update(_this.plugin)}}}),useLangStore.persist.rehydrate(),this._unload=fluxSubscribe("I18N_LOAD_SUCCESS",function(){return useLangStore.persist.rehydrate()})}return _create_class(Lang2,[{key:"unload",value:function(){var _this__unload,_this;(_this__unload=(_this=this)._unload)===null||_this__unload===void 0||_this__unload.call(_this)}},{key:"format",value:function(_key,input){var _values_locale,_values_en,_DEFAULT_LANG;const key=_key,locale=Lang2.getLang(),values=useLangStore.getState().values;if(!values)return String(key);const val=((_values_locale=values[locale])===null||_values_locale===void 0?void 0:_values_locale[key])??((_values_en=values.en)===null||_values_en===void 0?void 0:_values_en[key])??((_DEFAULT_LANG=define_DEFAULT_LANG_default2)===null||_DEFAULT_LANG===void 0?void 0:_DEFAULT_LANG[key]);return val?Object.keys(input).length>0?new IntlMessageFormat(val).format(input):val:String(key)}}],[{key:"getLang",value:function(){var _i18n_getLocale;const lang2=((_i18n_getLocale=common.i18n.getLocale())===null||_i18n_getLocale===void 0?void 0:_i18n_getLocale.replace(/-/g,"_"))??"en";return lang2.startsWith("en_")?"en":lang2}},{key:"basicFormat",value:function(text){const rules=[{regex:/\*\*(.*?)\*\*/g,react:function(txt2){return React.createElement(common.ReactNative.Text,{style:{fontWeight:"900"}},txt2)}}],txt=text.split("");let off=0;for(const rule of rules){const matches=Array.from(text.matchAll(rule.regex));for(const match of matches)match[1]&&(txt.splice(match.index-off,match[0].length,rule.react(match[1])),off+=match[0].length-1)}return txt}}]),Lang2}();const avatarStuff=metro.findByProps("getUserAvatarURL","getUserAvatarSource"),UserStore=metro.findByStoreName("UserStore");let data;const fetchData=async function(){try{data=await(await utils.safeFetch(`${dataURL}?_=${exports.hash}`,{cache:"no-store"})).json()}catch(e){const txt=lang.format("log.fetch_error",{});console.error(`[UsrPFP] ${txt}`),_vendetta.logger.error(`${txt}
${e.stack}`),toasts.showToast(lang.format("toast.fetch_error",{}),assets.getAssetIDByName("Small"))}},getCustomAvatar=function(id,isStatic){if(!data.avatars[id])return;const avatar=data.avatars[id];if(isStatic&&urlExt(avatar)==="gif")return staticGifURL(avatar);const url=new URL(avatar);return url.searchParams.append("_",exports.hash),url.toString()},urlExt=function(url){return new URL(url).pathname.split(".").slice(-1)[0]};async function patcher(){const patches=new Array;if(await fetchData(),!data||!exports.enabled)return function(){};const dataInterval=setInterval(function(){return fetchData()},1e3*60*60);return patches.push(function(){return clearInterval(dataInterval)}),patches.push(patcher$1.after("getUser",UserStore,function(param,ret){let[id]=param;if((data.avatars[id]&&urlExt(data.avatars[id]))==="gif"&&ret){const avatar=ret.avatar??"0";ret.avatar=avatar.startsWith("a_")?avatar:`a_${avatar}`}})),patches.push(patcher$1.after("getUserAvatarURL",avatarStuff,function(param){let[{id},animate]=param;return getCustomAvatar(id,!animate)})),patches.push(patcher$1.after("getUserAvatarSource",avatarStuff,function(param,ret){let[{id},animate]=param;const custom=getCustomAvatar(id,!animate);if(custom)return custom?{uri:custom}:ret})),function(){return patches.forEach(function(x){return x()})}}const dataURL="https://userpfp.github.io/UserPFP/source/data.json",staticGifURL=function(url){return`https://static-gif.nexpid.workers.dev/convert.gif?url=${encodeURIComponent(url)}&_=${exports.hash}`};exports.enabled=!1,exports.hash=void 0;const lang=new Lang("usrpfp");let unpatch;var index={onLoad:async function(){exports.hash=Array.from(crypto.getRandomValues(new Uint8Array(20))).map(function(b){return b.toString(16).padStart(2,"0")}).join(""),exports.enabled=!0;try{unpatch=await patcher()}catch(e){const txt=lang.format("log.patch_error",{});console.error(`[UsrPFP] ${txt}`),_vendetta.logger.error(`${txt}
${e.stack}`),toasts.showToast(lang.format("toast.patch_error",{}),assets.getAssetIDByName("Small")),plugins.stopPlugin(plugin.id)}},onUnload:function(){exports.enabled=!1,lang.unload(),unpatch?.()}};return exports.dataURL=dataURL,exports.default=index,exports.lang=lang,exports.staticGifURL=staticGifURL,Object.defineProperty(exports,"__esModule",{value:!0}),exports})({},vendetta,vendetta.plugin,vendetta.plugins,vendetta.ui.assets,vendetta.ui.toasts,vendetta.metro,vendetta.metro.common,vendetta.patcher,vendetta.utils);
